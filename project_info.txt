
## repo file structure:

bluesky-alt-text-slinger/
├── Bluesky_alt-text_slinger_plan.md
├── Dockerfile
├── README.md
├── backend/
│   ├── __init__.py
│   ├── alt_text_gen.py
│   ├── db.py
│   ├── main.py
│   └── requirements.txt
└── frontend/
    ├── index.html
    ├── package.json
    ├── tsconfig.json
    ├── vite.config.ts
    └── src/
        ├── App.css
        ├── App.tsx
        ├── api.ts
        └── main.tsx

Everything below is ready to paste into those files.

⸻

2. Root files

2.1 Bluesky_alt-text_slinger_plan.md

# Bluesky Alt-Text Slinger – Plan

## 1. High-level architecture

Linux-based web app that:

1. Authenticates to Bluesky using handle + app password.
2. Enumerates all posts with `app.bsky.embed.images` embeds.
3. Displays:
   - Image thumbnails
   - Existing alt text (if any)
   - Suggested alt text (generated by a vision model)
4. Lets the user:
   - Edit alt text for each image
   - Choose which images to update
   - Apply changes back to Bluesky by editing `app.bsky.embed.images.Image.alt`.

Core components:

- Backend: Python + FastAPI
- Bluesky client: `atproto` Python SDK
- Alt-text generator: OpenAI Vision (e.g. `gpt-4o-mini`), pluggable
- Frontend: React (Vite + TS) SPA with a textured, non-purple theme
- Storage: SQLite (via `sqlite3`) for:
  - Users
  - Posts
  - Images (existing + generated alt text, applied status)
- Containerization: Docker image running the backend; frontend runs via Vite dev or separate static hosting.

---

## 2. Bluesky / ATProto flow

- Login with `Client.login(handle, app_password)` using an app password.
- Scan posts with `get_author_feed` and filter to `app.bsky.embed.images#view` embeds.
- For each image:
  - Collect thumb & fullsize URLs and existing `alt`.
- For updates:
  - Parse `at://did/.../app.bsky.feed.post/rkey` URIs.
  - Get the record via `com.atproto.repo.getRecord`.
  - Ensure `record.embed.$type == "app.bsky.embed.images"`.
  - Set `record.embed.images[i].alt = new_alt`.
  - Write back with `com.atproto.repo.putRecord`.

---

## 3. Database schema (SQLite)

Tables:

- `users`
  - `handle` (TEXT PRIMARY KEY)
  - `created_at` (TEXT, default now)

- `posts`
  - `id` (INTEGER PK AUTOINCREMENT)
  - `handle` (TEXT NOT NULL)
  - `uri` (TEXT NOT NULL)
  - `cid` (TEXT)
  - `text` (TEXT)
  - `created_at` (TEXT)
  - `has_images` (INTEGER, 0/1)
  - UNIQUE (`handle`, `uri`)

- `images`
  - `id` (INTEGER PK AUTOINCREMENT)
  - `handle` (TEXT NOT NULL)
  - `post_uri` (TEXT NOT NULL)
  - `image_index` (INTEGER NOT NULL)
  - `thumb_url` (TEXT)
  - `fullsize_url` (TEXT)
  - `current_alt` (TEXT)
  - `generated_alt` (TEXT)
  - `last_applied_alt` (TEXT)
  - `last_status` (TEXT)
  - `updated_at` (TEXT, default now)
  - UNIQUE (`handle`, `post_uri`, `image_index`)

On scan:

- Insert/update `posts` and `images` with latest info.
- Optionally overwrite `generated_alt` with new suggestions.

On apply:

- Update `images.current_alt`, `last_applied_alt`, `last_status`.

---

## 4. Backend endpoints

### `POST /api/scan`

Request:

- `handle`
- `app_password`
- `generate_alt` (bool, default true)

Behavior:

- Login to Bluesky.
- Fetch all posts with images.
- For each image:
  - Include thumb/fullsize URLs, existing `alt`.
  - If `generate_alt` is true and there is no existing alt AND an OpenAI key is present:
    - Generate suggested alt text.
- Save scan results to SQLite.
- Return `ScanResponse` (posts + images + flags).

### `POST /api/apply`

Request:

- `handle`
- `app_password`
- `updates`: list of `{ uri, image_index, new_alt }`.

Behavior:

- Login to Bluesky.
- Group updates by post URI.
- For each post:
  - Fetch record, patch `embed.images[i].alt`.
  - Write back with `putRecord`.
- Update SQLite with application status.
- Return per-URI success/failure list.

---

## 5. Frontend (React)

Key features:

- Login form for handle + app password.
- On scan:
  - Show summary (post count, image count, alt-gen status).
  - Gallery of image cards with:
    - Thumbnail
    - Post text
    - Existing alt text
    - Suggested alt text
    - Editable textarea “alt text to apply”
    - Checkbox “Apply this alt text to Bluesky”
- Filters:
  - Show all
  - Only images missing alt
  - Only images with existing alt
  - Only selected images
- Bulk actions:
  - Select all images with missing alt
  - Clear all selections
- Apply button:
  - Sends selected alt text updates to `/api/apply`.
  - Shows summary banner on success.

Styling:

- Deep slate/blue-gray background with subtle texture.
- Non-purple accents (emerald, teal, blue).
- Glassy cards, rounded corners, soft shadows.

---

## 6. Docker & deployment

- Backend runs in a Python 3.12 slim image:
  - Installs `backend/requirements.txt`.
  - Uses `uvicorn backend.main:app`.
  - SQLite DB path at `/app/data/alttext_slinger.db` (configurable via `ALTTS_DB_PATH`).
- You can mount a host directory as `/app/data` for persistence.
- Frontend runs separately (Vite dev or static build served by your choice of web server).

---


⸻

2.2 Dockerfile

Backend-only container; you run frontend via Vite (or a separate static host):

FROM python:3.12-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# Install backend dependencies
COPY backend/requirements.txt ./backend/requirements.txt
RUN pip install --no-cache-dir -r backend/requirements.txt

# Copy backend code
COPY backend ./backend

# Data dir for SQLite (can be overridden with ALTTS_DB_PATH)
RUN mkdir -p /app/data
ENV ALTTS_DB_PATH=/app/data/alttext_slinger.db

EXPOSE 8000

CMD ["uvicorn", "backend.main:app", "--host", "0.0.0.0", "--port", "8000"]


⸻

2.3 README.md

# Bluesky Alt-Text Slinger

A Linux-friendly web app that connects to your Bluesky account, scans all posts with images, generates suggested alt text, and lets you review + apply alt text updates back to Bluesky.

- Backend: FastAPI + `atproto` + OpenAI
- Frontend: React (Vite + TypeScript)
- Storage: SQLite
- Container: Docker (backend)

> **Important:** Use a **Bluesky app password**, not your main password.

---

## Features

- Login with Bluesky handle + app password
- Scan all posts with `app.bsky.embed.images`
- Show:
  - Thumbnails
  - Existing alt text
  - Suggested alt text (via OpenAI Vision)
- Edit **alt text to apply** per image
- Select which images to update and apply in bulk
- Filters:
  - All images
  - Only images missing alt
  - Only images with existing alt
  - Only selected images
- Bulk actions:
  - Select all missing-alt images
  - Clear all selections
- SQLite database for caching scans and applied updates

---

## Prerequisites

- Python 3.11+ (for backend if not using Docker)
- Node 18+ (for frontend)
- A Bluesky account with an **app password**
- An OpenAI API key (for alt-text generation)

---

## Backend (dev)

```bash
cd backend
python -m venv .venv
source .venv/bin/activate  # or .venv\Scripts\activate on Windows

pip install -r requirements.txt

export OPENAI_API_KEY="sk-..."           # required for suggestions
export ALTTS_DB_PATH="./alttext_slinger.db"  # optional; defaults to backend-local file

uvicorn backend.main:app --reload --port 8000

The API will be available at http://localhost:8000.

⸻

Frontend (dev)

cd frontend
npm install
npm run dev

By default, Vite serves at http://localhost:5173.

The frontend expects the backend at http://localhost:8000. You can change that in src/api.ts if needed.

⸻

Docker

Build the backend image:

docker build -t bluesky-alttext-slinger .

Run:

docker run --rm -p 8000:8000 \
  -e OPENAI_API_KEY="sk-..." \
  -e ALTTS_DB_PATH="/app/data/alttext_slinger.db" \
  -v "$(pwd)/data:/app/data" \
  bluesky-alttext-slinger

Then run the frontend separately (see above) and point it to http://localhost:8000.

⸻

Environment variables
	•	OPENAI_API_KEY – OpenAI API key (required for alt-text generation).
	•	ALTTS_DB_PATH – Path to SQLite DB (optional; defaults under backend/ or /app/data in Docker).
	•	ALTGEN_MODEL – Optional; defaults to gpt-4o-mini.

⸻

Notes
	•	No alt text is changed on Bluesky until you click “Apply Selected Alt Text”.
	•	You can revoke the app password anytime from Bluesky settings.
	•	This project is not affiliated with Bluesky or OpenAI; it’s just a client built on their APIs.

⸻


---

## 3. Backend

### 3.1 `backend/__init__.py`

```python
# Make backend a package


⸻

3.2 backend/requirements.txt

fastapi
uvicorn[standard]
atproto
python-multipart
openai


⸻

3.3 backend/alt_text_gen.py

import os
from typing import Optional

from openai import OpenAI  # pip install openai

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
ALTGEN_MODEL = os.getenv("ALTGEN_MODEL", "gpt-4o-mini")

_client: Optional[OpenAI] = None
if OPENAI_API_KEY:
    _client = OpenAI(api_key=OPENAI_API_KEY)


def is_enabled() -> bool:
    """
    Returns True if alt-text generation is configured (API key present).
    """
    return _client is not None


def generate_alt_text(image_url: str, post_text: Optional[str] = None) -> Optional[str]:
    """
    Generate concise alt-text for the given image URL using an OpenAI
    vision-capable chat model (e.g. gpt-4o / gpt-4o-mini).

    Returns a 1–2 sentence description, or None on error.
    """
    if not _client:
        return None

    context_snippet = (post_text or "").strip()
    if len(context_snippet) > 220:
        context_snippet = context_snippet[:220] + "…"

    user_prompt = (
        "Write concise, objective alt-text for this image for a blind screen-reader user. "
        "Maximum 2 sentences. Do not start with phrases like 'Image of' or 'Photo of'; "
        "just describe the key visual content and any text in the image. "
        f"Here is optional context from the post: {context_snippet or '(no extra context)'}"
    )

    try:
        resp = _client.chat.completions.create(
            model=ALTGEN_MODEL,
            messages=[
                {
                    "role": "system",
                    "content": (
                        "You generate high-quality accessibility alt-text for images. "
                        "Be concrete and neutral, avoid guessing unknown details."
                    ),
                },
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": user_prompt},
                        {
                            "type": "image_url",
                            "image_url": {"url": image_url},
                        },
                    ],
                },
            ],
            max_tokens=120,
            temperature=0.2,
        )
        text = resp.choices[0].message.content or ""
        return text.strip() or None
    except Exception as e:
        print(f"[alt_text_gen] Error generating alt-text: {e}")
        return None


⸻

3.4 backend/db.py (SQLite layer)

import os
import sqlite3
from typing import List, Dict, Any

DB_PATH = os.getenv(
    "ALTTS_DB_PATH",
    os.path.join(os.path.dirname(__file__), "alttext_slinger.db"),
)


def _get_conn() -> sqlite3.Connection:
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def init_db() -> None:
    conn = _get_conn()
    cur = conn.cursor()

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS users (
            handle TEXT PRIMARY KEY,
            created_at TEXT DEFAULT (datetime('now'))
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS posts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            handle TEXT NOT NULL,
            uri TEXT NOT NULL,
            cid TEXT,
            text TEXT,
            created_at TEXT,
            has_images INTEGER NOT NULL DEFAULT 1,
            UNIQUE(handle, uri)
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS images (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            handle TEXT NOT NULL,
            post_uri TEXT NOT NULL,
            image_index INTEGER NOT NULL,
            thumb_url TEXT,
            fullsize_url TEXT,
            current_alt TEXT,
            generated_alt TEXT,
            last_applied_alt TEXT,
            last_status TEXT,
            updated_at TEXT DEFAULT (datetime('now')),
            UNIQUE(handle, post_uri, image_index)
        );
        """
    )

    conn.commit()
    conn.close()


def save_scan(handle: str, posts: List[Dict[str, Any]]) -> None:
    """
    Persist scan results to SQLite.

    posts: list of dicts shaped like PostInfo.model_dump()
    """
    conn = _get_conn()
    cur = conn.cursor()

    cur.execute("INSERT OR IGNORE INTO users(handle) VALUES (?)", (handle,))

    for post in posts:
        uri = post["uri"]
        cid = post.get("cid")
        text = post.get("text")
        created_at = post.get("created_at")

        cur.execute(
            """
            INSERT INTO posts (handle, uri, cid, text, created_at, has_images)
            VALUES (?, ?, ?, ?, ?, 1)
            ON CONFLICT(handle, uri) DO UPDATE SET
                cid = excluded.cid,
                text = excluded.text,
                created_at = excluded.created_at,
                has_images = excluded.has_images;
            """,
            (handle, uri, cid, text, created_at),
        )

        for img in post.get("images", []):
            idx = img["index"]
            thumb_url = img.get("thumb_url")
            fullsize_url = img.get("fullsize_url")
            current_alt = img.get("alt")
            generated_alt = img.get("generated_alt")

            cur.execute(
                """
                INSERT INTO images (
                    handle, post_uri, image_index,
                    thumb_url, fullsize_url,
                    current_alt, generated_alt, last_status
                )
                VALUES (?, ?, ?, ?, ?, ?, ?, 'scanned')
                ON CONFLICT(handle, post_uri, image_index) DO UPDATE SET
                    thumb_url = excluded.thumb_url,
                    fullsize_url = excluded.fullsize_url,
                    current_alt = excluded.current_alt,
                    generated_alt = excluded.generated_alt,
                    last_status = 'scanned',
                    updated_at = datetime('now');
                """,
                (
                    handle,
                    uri,
                    idx,
                    thumb_url,
                    fullsize_url,
                    current_alt,
                    generated_alt,
                ),
            )

    conn.commit()
    conn.close()


def record_image_update(
    handle: str,
    uri: str,
    image_index: int,
    new_alt: str,
    status: str,
) -> None:
    """
    Record that an image alt was applied (or failed).
    """
    conn = _get_conn()
    cur = conn.cursor()

    cur.execute(
        """
        UPDATE images
        SET
            current_alt = ?,
            last_applied_alt = ?,
            last_status = ?,
            updated_at = datetime('now')
        WHERE handle = ? AND post_uri = ? AND image_index = ?;
        """,
        (new_alt, new_alt, status, handle, uri, image_index),
    )

    # If no row existed (unlikely but possible), insert one
    if cur.rowcount == 0:
        cur.execute(
            """
            INSERT INTO images (
                handle, post_uri, image_index,
                current_alt, last_applied_alt, last_status
            )
            VALUES (?, ?, ?, ?, ?, ?)
            ON CONFLICT(handle, post_uri, image_index) DO UPDATE SET
                current_alt = excluded.current_alt,
                last_applied_alt = excluded.last_applied_alt,
                last_status = excluded.last_status,
                updated_at = datetime('now');
            """,
            (handle, uri, image_index, new_alt, new_alt, status),
        )

    conn.commit()
    conn.close()


⸻

3.5 backend/main.py (with DB + scan + apply)

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict

from atproto import Client

from .alt_text_gen import is_enabled as altgen_is_enabled, generate_alt_text
from . import db


# ---------- Pydantic models ----------

class ScanRequest(BaseModel):
    handle: str
    app_password: str
    generate_alt: bool = True


class ImageInfo(BaseModel):
    index: int
    thumb_url: str
    fullsize_url: str
    alt: Optional[str] = None
    generated_alt: Optional[str] = None


class PostInfo(BaseModel):
    uri: str
    cid: str
    text: str
    created_at: Optional[str]
    images: List[ImageInfo]


class ScanResponse(BaseModel):
    handle: str
    total_posts: int
    total_images: int
    posts: List[PostInfo]
    alt_generation_enabled: bool


class AltUpdate(BaseModel):
    uri: str
    image_index: int
    new_alt: str


class ApplyRequest(BaseModel):
    handle: str
    app_password: str
    updates: List[AltUpdate]


class ApplyResultItem(BaseModel):
    uri: str
    success: bool
    error: Optional[str] = None


class ApplyResponse(BaseModel):
    updated: List[ApplyResultItem]


# ---------- App setup ----------

app = FastAPI(title="Bluesky Alt-Text Slinger – Phase 4")

origins = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize SQLite tables at import time
db.init_db()


# ---------- Helpers ----------

def parse_at_uri(uri: str):
    """
    Parse an AT URI of the form:
      at://did:plc:.../app.bsky.feed.post/rkey
    into (did, collection, rkey).
    """
    if not uri.startswith("at://"):
        raise ValueError(f"Not a valid at:// URI: {uri}")
    parts = uri[5:].split("/")
    if len(parts) != 3:
        raise ValueError(f"Unexpected AT URI format: {uri}")
    did, collection, rkey = parts
    return did, collection, rkey


# ---------- /api/scan ----------

@app.post("/api/scan", response_model=ScanResponse)
def scan_images(req: ScanRequest) -> ScanResponse:
    client = Client()

    try:
        client.login(req.handle, req.app_password)
    except Exception as e:
        raise HTTPException(
            status_code=401,
            detail="Failed to login to Bluesky. Check handle/app password.",
        ) from e

    posts_with_images: List[PostInfo] = []
    cursor = None

    altgen_active = altgen_is_enabled() and req.generate_alt

    while True:
        try:
            feed = client.get_author_feed(actor=req.handle, cursor=cursor)
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"Error fetching author feed: {e}",
            )

        for item in feed.feed:
            post = item.post
            record = post.record
            uri = post.uri
            cid = post.cid

            embed = getattr(post, "embed", None)
            if not embed or getattr(embed, "$type", "") != "app.bsky.embed.images#view":
                continue

            text = getattr(record, "text", "") or ""
            created_at = getattr(record, "created_at", None)

            images: List[ImageInfo] = []
            for idx, img in enumerate(embed.images):
                alt = img.alt if hasattr(img, "alt") else None
                thumb_url = img.thumb
                fullsize_url = img.fullsize

                generated_alt: Optional[str] = None
                if altgen_active and (not alt or not alt.strip()):
                    generated_alt = generate_alt_text(fullsize_url, text)

                images.append(
                    ImageInfo(
                        index=idx,
                        thumb_url=thumb_url,
                        fullsize_url=fullsize_url,
                        alt=alt,
                        generated_alt=generated_alt,
                    )
                )

            posts_with_images.append(
                PostInfo(
                    uri=uri,
                    cid=cid,
                    text=text,
                    created_at=created_at,
                    images=images,
                )
            )

        cursor = feed.cursor
        if not cursor:
            break

    total_images = sum(len(p.images) for p in posts_with_images)

    # Persist scan results to SQLite
    db.save_scan(req.handle, [p.model_dump() for p in posts_with_images])

    return ScanResponse(
        handle=req.handle,
        total_posts=len(posts_with_images),
        total_images=total_images,
        posts=posts_with_images,
        alt_generation_enabled=altgen_active,
    )


# ---------- /api/apply ----------

@app.post("/api/apply", response_model=ApplyResponse)
def apply_alt_updates(req: ApplyRequest) -> ApplyResponse:
    if not req.updates:
        return ApplyResponse(updated=[])

    client = Client()
    try:
        client.login(req.handle, req.app_password)
    except Exception as e:
        raise HTTPException(
            status_code=401,
            detail="Failed to login to Bluesky. Check handle/app password.",
        ) from e

    updates_by_uri: Dict[str, List[AltUpdate]] = {}
    for upd in req.updates:
        updates_by_uri.setdefault(upd.uri, []).append(upd)

    results: List[ApplyResultItem] = []

    for uri, updates in updates_by_uri.items():
        try:
            did, collection, rkey = parse_at_uri(uri)

            rec_resp = client.com.atproto.repo.get_record(
                repo=did,
                collection=collection,
                rkey=rkey,
            )

            record = getattr(rec_resp, "value", None)
            if record is None:
                if isinstance(rec_resp, dict) and "value" in rec_resp:
                    record = rec_resp["value"]
                else:
                    raise RuntimeError("Could not locate record value in response")

            embed = record.get("embed")
            if not embed:
                raise RuntimeError("Record has no embed")
            if embed.get("$type") != "app.bsky.embed.images":
                raise RuntimeError(
                    f"Embed type is not app.bsky.embed.images: {embed.get('$type')}"
                )

            images = embed.get("images") or []
            if not isinstance(images, list):
                raise RuntimeError("Record embed.images is not a list")

            # Apply updates
            for upd in updates:
                idx = upd.image_index
                if idx < 0 or idx >= len(images):
                    continue
                images[idx]["alt"] = upd.new_alt

            client.com.atproto.repo.put_record(
                repo=did,
                collection=collection,
                rkey=rkey,
                record=record,
            )

            # Record each update in SQLite as "applied"
            for upd in updates:
                db.record_image_update(
                    handle=req.handle,
                    uri=uri,
                    image_index=upd.image_index,
                    new_alt=upd.new_alt,
                    status="applied",
                )

            results.append(
                ApplyResultItem(
                    uri=uri,
                    success=True,
                    error=None,
                )
            )

        except Exception as e:
            # Record failed updates
            for upd in updates:
                db.record_image_update(
                    handle=req.handle,
                    uri=uri,
                    image_index=upd.image_index,
                    new_alt=upd.new_alt,
                    status="failed",
                )

            results.append(
                ApplyResultItem(
                    uri=uri,
                    success=False,
                    error=str(e),
                )
            )

    return ApplyResponse(updated=results)


⸻

4. Frontend

4.1 frontend/package.json

{
  "name": "bluesky-alt-text-slinger-frontend",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "echo \"no lint configured\""
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.7.0",
    "typescript": "^5.5.3",
    "vite": "^5.4.0"
  }
}


⸻

4.2 frontend/tsconfig.json

{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"]
}


⸻

4.3 frontend/vite.config.ts

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173
  }
});


⸻

4.4 frontend/index.html

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Bluesky Alt-Text Slinger</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


⸻

4.5 frontend/src/api.ts

export interface ScanRequest {
  handle: string;
  app_password: string;
  generate_alt?: boolean; // defaults to true on backend
}

export interface ImageInfo {
  index: number;
  thumb_url: string;
  fullsize_url: string;
  alt?: string | null;
  generated_alt?: string | null;
}

export interface PostInfo {
  uri: string;
  cid: string;
  text: string;
  created_at?: string | null;
  images: ImageInfo[];
}

export interface ScanResponse {
  handle: string;
  total_posts: number;
  total_images: number;
  posts: PostInfo[];
  alt_generation_enabled: boolean;
}

const API_BASE = "http://localhost:8000";

export async function scanImages(req: ScanRequest): Promise<ScanResponse> {
  const res = await fetch(`${API_BASE}/api/scan`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      ...req,
      generate_alt: req.generate_alt ?? true
    })
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error(text || `HTTP error ${res.status}`);
  }

  return res.json();
}

// ---------- Phase 3 apply ----------

export interface AltUpdate {
  uri: string;
  image_index: number;
  new_alt: string;
}

export interface ApplyResultItem {
  uri: string;
  success: boolean;
  error?: string;
}

export interface ApplyResponse {
  updated: ApplyResultItem[];
}

export async function applyAltUpdates(
  handle: string,
  app_password: string,
  updates: AltUpdate[]
): Promise<ApplyResponse> {
  const res = await fetch(`${API_BASE}/api/apply`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      handle,
      app_password,
      updates
    })
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error(text || `HTTP error ${res.status}`);
  }

  return res.json();
}


⸻

4.6 frontend/src/main.tsx

import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./App.css";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


⸻

4.7 frontend/src/App.tsx (filters + bulk select + apply)

import React, { useState } from "react";
import "./App.css";
import {
  scanImages,
  ScanResponse,
  PostInfo,
  ImageInfo,
  applyAltUpdates,
  AltUpdate,
  ApplyResponse
} from "./api";

function formatDate(dateStr?: string | null): string {
  if (!dateStr) return "";
  const d = new Date(dateStr);
  if (Number.isNaN(d.getTime())) return dateStr;
  return d.toLocaleString();
}

type AltState = {
  apply: boolean;
  draftAlt: string;
};

type AltStateMap = {
  [key: string]: AltState;
};

function makeKey(uri: string, index: number): string {
  return `${uri}::${index}`;
}

type FilterMode = "all" | "missingAlt" | "hasAlt" | "selected";

const App: React.FC = () => {
  const [handle, setHandle] = useState("");
  const [appPassword, setAppPassword] = useState("");
  const [loading, setLoading] = useState(false);
  const [applying, setApplying] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [applyMessage, setApplyMessage] = useState<string | null>(null);
  const [result, setResult] = useState<ScanResponse | null>(null);
  const [altState, setAltState] = useState<AltStateMap>({});
  const [filterMode, setFilterMode] = useState<FilterMode>("all");

  const initAltStateFromResult = (data: ScanResponse) => {
    const next: AltStateMap = {};
    data.posts.forEach((post) => {
      post.images.forEach((img) => {
        const key = makeKey(post.uri, img.index);
        const baseAlt =
          img.alt && img.alt.trim().length > 0 ? img.alt : img.generated_alt || "";
        next[key] = {
          apply: !img.alt || img.alt.trim().length === 0, // default: auto-select only images with no existing alt
          draftAlt: baseAlt
        };
      });
    });
    setAltState(next);
  };

  const onSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setApplyMessage(null);
    setResult(null);
    setAltState({});

    if (!handle || !appPassword) {
      setError("Please enter both handle and app password.");
      return;
    }

    setLoading(true);
    try {
      const data = await scanImages({
        handle,
        app_password: appPassword,
        generate_alt: true
      });
      setResult(data);
      initAltStateFromResult(data);
    } catch (err: any) {
      console.error(err);
      let msg = "An error occurred while scanning.";
      try {
        const parsed = JSON.parse(err.message);
        if (parsed?.detail) {
          msg =
            typeof parsed.detail === "string"
              ? parsed.detail
              : JSON.stringify(parsed.detail);
        }
      } catch {
        if (err.message) msg = err.message;
      }
      setError(msg);
    } finally {
      setLoading(false);
    }
  };

  const handleAltChange = (uri: string, index: number, value: string) => {
    const key = makeKey(uri, index);
    setAltState((prev) => ({
      ...prev,
      [key]: {
        apply: prev[key]?.apply ?? false,
        draftAlt: value
      }
    }));
  };

  const handleApplyToggle = (uri: string, index: number, apply: boolean) => {
    const key = makeKey(uri, index);
    setAltState((prev) => ({
      ...prev,
      [key]: {
        apply,
        draftAlt: prev[key]?.draftAlt ?? ""
      }
    }));
  };

  const onApplyChanges = async () => {
    if (!result) return;
    setApplyMessage(null);
    setError(null);

    const updates: AltUpdate[] = [];

    result.posts.forEach((post: PostInfo) => {
      post.images.forEach((img: ImageInfo) => {
        const key = makeKey(post.uri, img.index);
        const state = altState[key];
        if (!state || !state.apply) return;
        const draft = state.draftAlt?.trim();
        if (!draft) return;
        updates.push({
          uri: post.uri,
          image_index: img.index,
          new_alt: draft
        });
      });
    });

    if (updates.length === 0) {
      setApplyMessage("No images selected for update.");
      return;
    }

    setApplying(true);
    try {
      const resp: ApplyResponse = await applyAltUpdates(handle, appPassword, updates);
      const successes = resp.updated.filter((r) => r.success).length;
      const failures = resp.updated.length - successes;

      setApplyMessage(
        `Applied alt text to ${successes} post(s).` +
          (failures > 0 ? ` ${failures} post(s) failed; check logs/errors.` : "")
      );

      // Optimistically update result alt fields for the UI
      const nextResult: ScanResponse = {
        ...result,
        posts: result.posts.map((post) => ({
          ...post,
          images: post.images.map((img) => {
            const key = makeKey(post.uri, img.index);
            const state = altState[key];
            if (state?.apply && state.draftAlt.trim()) {
              return {
                ...img,
                alt: state.draftAlt.trim()
              };
            }
            return img;
          })
        }))
      };
      setResult(nextResult);
    } catch (err: any) {
      console.error(err);
      let msg = "An error occurred while applying changes.";
      try {
        const parsed = JSON.parse(err.message);
        if (parsed?.detail) {
          msg =
            typeof parsed.detail === "string"
              ? parsed.detail
              : JSON.stringify(parsed.detail);
        }
      } catch {
        if (err.message) msg = err.message;
      }
      setError(msg);
    } finally {
      setApplying(false);
    }
  };

  const bulkSelectMissingAlt = () => {
    if (!result) return;
    setAltState((prev) => {
      const next: AltStateMap = { ...prev };
      result.posts.forEach((post) => {
        post.images.forEach((img) => {
          const key = makeKey(post.uri, img.index);
          const hasAlt = img.alt && img.alt.trim().length > 0;
          if (!hasAlt) {
            const existing = next[key] ?? {
              apply: false,
              draftAlt:
                img.alt && img.alt.trim().length > 0
                  ? img.alt
                  : img.generated_alt || ""
            };
            next[key] = {
              ...existing,
              apply: true
            };
          }
        });
      });
      return next;
    });
  };

  const bulkClearSelections = () => {
    setAltState((prev) => {
      const next: AltStateMap = {};
      for (const [key, value] of Object.entries(prev)) {
        next[key] = { ...value, apply: false };
      }
      return next;
    });
  };

  const shouldShowImage = (post: PostInfo, img: ImageInfo): boolean => {
    const key = makeKey(post.uri, img.index);
    const state = altState[key];
    const hasAlt = img.alt && img.alt.trim().length > 0;
    const isSelected = !!state?.apply;

    switch (filterMode) {
      case "missingAlt":
        return !hasAlt;
      case "hasAlt":
        return hasAlt;
      case "selected":
        return isSelected;
      case "all":
      default:
        return true;
    }
  };

  return (
    <div className="app-root">
      <div className="texture-overlay" />
      <header className="app-header">
        <h1>Bluesky Alt-Text Slinger</h1>
        <p className="subtitle">
          Phase 4: Scan, review suggestions, apply updates, with filters and SQLite persistence.
        </p>
      </header>

      <main className="app-main">
        <section className="card login-card">
          <h2>Connect to Bluesky</h2>
          <p className="card-help">
            Use your Bluesky handle and an <strong>app password</strong>, not your main password.
          </p>
          <form onSubmit={onSubmit} className="login-form">
            <label className="input-group">
              <span>Handle</span>
              <input
                type="text"
                placeholder="you.bsky.social"
                value={handle}
                onChange={(e) => setHandle(e.target.value)}
              />
            </label>

            <label className="input-group">
              <span>App Password</span>
              <input
                type="password"
                placeholder="xxxx-xxxx-xxxx-xxxx"
                value={appPassword}
                onChange={(e) => setAppPassword(e.target.value)}
              />
            </label>

            <button type="submit" className="primary-btn" disabled={loading}>
              {loading ? "Scanning..." : "Scan My Posts"}
            </button>

            {error && <div className="error-banner">{error}</div>}
          </form>
        </section>

        {result && (
          <section className="card results-card">
            <div className="results-header">
              <h2>Scan Results</h2>
              <p>
                Handle: <strong>{result.handle}</strong> · Posts with images:{" "}
                <strong>{result.total_posts}</strong> · Images:{" "}
                <strong>{result.total_images}</strong>
              </p>
              <p className="altgen-status">
                Alt-text generation:{" "}
                {result.alt_generation_enabled ? (
                  <span className="badge badge-on">Enabled</span>
                ) : (
                  <span className="badge badge-off">Disabled (no API key)</span>
                )}
              </p>
            </div>

            {applyMessage && <div className="apply-banner">{applyMessage}</div>}

            <div className="top-controls">
              <div className="apply-controls">
                <button
                  type="button"
                  className="primary-btn"
                  disabled={applying}
                  onClick={onApplyChanges}
                >
                  {applying ? "Applying..." : "Apply Selected Alt Text"}
                </button>
                <span className="apply-hint">
                  Only images with the checkbox enabled and non-empty alt text will be updated.
                </span>
              </div>

              <div className="filter-controls">
                <span className="filter-label">Filter:</span>
                <button
                  type="button"
                  className={`filter-btn ${filterMode === "all" ? "filter-btn-active" : ""}`}
                  onClick={() => setFilterMode("all")}
                >
                  All
                </button>
                <button
                  type="button"
                  className={`filter-btn ${
                    filterMode === "missingAlt" ? "filter-btn-active" : ""
                  }`}
                  onClick={() => setFilterMode("missingAlt")}
                >
                  Missing alt
                </button>
                <button
                  type="button"
                  className={`filter-btn ${
                    filterMode === "hasAlt" ? "filter-btn-active" : ""
                  }`}
                  onClick={() => setFilterMode("hasAlt")}
                >
                  Has alt
                </button>
                <button
                  type="button"
                  className={`filter-btn ${
                    filterMode === "selected" ? "filter-btn-active" : ""
                  }`}
                  onClick={() => setFilterMode("selected")}
                >
                  Selected
                </button>

                <span className="filter-divider" />

                <button
                  type="button"
                  className="filter-btn"
                  onClick={bulkSelectMissingAlt}
                >
                  Select all missing-alt
                </button>
                <button
                  type="button"
                  className="filter-btn"
                  onClick={bulkClearSelections}
                >
                  Clear selections
                </button>
              </div>
            </div>

            {result.total_images === 0 ? (
              <p>No images with embeds found in your posts.</p>
            ) : (
              <div className="images-grid">
                {result.posts.map((post: PostInfo) =>
                  post.images
                    .filter((img) => shouldShowImage(post, img))
                    .map((img: ImageInfo) => {
                      const key = makeKey(post.uri, img.index);
                      const state = altState[key] || {
                        apply: false,
                        draftAlt:
                          img.alt && img.alt.trim().length > 0
                            ? img.alt
                            : img.generated_alt || ""
                      };

                      return (
                        <article key={`${post.uri}-${img.index}`} className="image-card">
                          <div className="image-wrapper">
                            <img
                              src={img.thumb_url}
                              alt={img.alt || img.generated_alt || "Image thumbnail"}
                              className="image-thumb"
                            />
                          </div>
                          <div className="image-meta">
                            <div className="meta-row">
                              <span className="meta-label">Post text</span>
                              <span className="meta-value meta-text">
                                {post.text || <em>(no post text)</em>}
                              </span>
                            </div>
                            <div className="meta-row">
                              <span className="meta-label">Created</span>
                              <span className="meta-value">
                                {post.created_at ? (
                                  formatDate(post.created_at)
                                ) : (
                                  <em>unknown</em>
                                )}
                              </span>
                            </div>
                            <div className="meta-row">
                              <span className="meta-label">Existing alt text</span>
                              <span className="meta-value meta-alt">
                                {img.alt && img.alt.trim().length > 0 ? (
                                  img.alt
                                ) : (
                                  <em>(no alt text set)</em>
                                )}
                              </span>
                            </div>

                            <div className="meta-row">
                              <span className="meta-label">Suggested alt text</span>
                              <span className="meta-value meta-alt suggested-alt">
                                {img.generated_alt && img.generated_alt.trim().length > 0 ? (
                                  img.generated_alt
                                ) : result.alt_generation_enabled ? (
                                  <em>(no suggestion returned)</em>
                                ) : (
                                  <em>(configure OPENAI_API_KEY to enable suggestions)</em>
                                )}
                              </span>
                            </div>

                            <div className="meta-row">
                              <span className="meta-label">Alt text to apply</span>
                              <textarea
                                className="alt-textarea"
                                value={state.draftAlt}
                                onChange={(e) =>
                                  handleAltChange(post.uri, img.index, e.target.value)
                                }
                                rows={3}
                                placeholder="Type or refine alt text here"
                              />
                            </div>

                            <div className="meta-row apply-row">
                              <label className="apply-checkbox">
                                <input
                                  type="checkbox"
                                  checked={state.apply}
                                  onChange={(e) =>
                                    handleApplyToggle(
                                      post.uri,
                                      img.index,
                                      e.target.checked
                                    )
                                  }
                                />
                                <span>Apply this alt text to Bluesky</span>
                              </label>
                              <span className="meta-value">Image index #{img.index}</span>
                            </div>

                            <div className="meta-row link-row">
                              <a
                                href={post.uri}
                                target="_blank"
                                rel="noreferrer"
                                className="post-link"
                              >
                                View post (URI)
                              </a>
                              <a
                                href={img.fullsize_url}
                                target="_blank"
                                rel="noreferrer"
                                className="post-link"
                              >
                                Full-size image
                              </a>
                            </div>
                          </div>
                        </article>
                      );
                    })
                )}
              </div>
            )}
          </section>
        )}
      </main>

      <footer className="app-footer">
        <span>
          Phase 4 – changes you apply here update alt text on your Bluesky posts and are tracked
          in SQLite.
        </span>
      </footer>
    </div>
  );
};

export default App;


⸻

4.8 frontend/src/App.css (with filters & bulk controls, no purple gradients)

If you already have the earlier CSS, you can replace it with this superset:

:root {
  --bg-base: #0f172a; /* deep slate blue/gray, not purple */
  --bg-card: rgba(15, 23, 42, 0.9);
  --accent: #22c55e; /* emerald */
  --accent-soft: rgba(34, 197, 94, 0.12);
  --text-main: #e5e7eb;
  --text-muted: #9ca3af;
  --border-subtle: rgba(148, 163, 184, 0.3);
  --error: #f97373;
}

/* Textured background using layered gradients (no purple) */
body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  color: var(--text-main);
  background-color: var(--bg-base);
  background-image:
    radial-gradient(circle at 0 0, rgba(255, 255, 255, 0.06) 0, transparent 55%),
    radial-gradient(circle at 100% 100%, rgba(15, 118, 110, 0.16) 0, transparent 60%),
    radial-gradient(circle at 0 100%, rgba(30, 64, 175, 0.18) 0, transparent 60%);
  background-attachment: fixed;
}

.app-root {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  position: relative;
}

.texture-overlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.2;
  background-image:
    repeating-linear-gradient(
      45deg,
      rgba(15, 23, 42, 0.4),
      rgba(15, 23, 42, 0.4) 1px,
      rgba(15, 23, 42, 0.2) 1px,
      rgba(15, 23, 42, 0.2) 2px
    );
  mix-blend-mode: soft-light;
  z-index: 0;
}

.app-header {
  position: relative;
  z-index: 1;
  padding: 2.5rem 1.5rem 1rem;
  text-align: center;
}

.app-header h1 {
  margin: 0;
  font-size: 2.4rem;
  letter-spacing: 0.02em;
}

.subtitle {
  margin-top: 0.5rem;
  color: var(--text-muted);
  font-size: 0.98rem;
}

.app-main {
  position: relative;
  z-index: 1;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  max-width: 1200px;
  margin: 0 auto 2.5rem;
  padding: 0 1.5rem 2rem;
  box-sizing: border-box;
}

.card {
  background: var(--bg-card);
  backdrop-filter: blur(20px);
  border-radius: 1rem;
  border: 1px solid var(--border-subtle);
  box-shadow:
    0 18px 45px rgba(15, 23, 42, 0.7),
    0 1px 0 rgba(255, 255, 255, 0.03);
  padding: 1.5rem 1.75rem;
}

.login-card {
  max-width: 520px;
  margin: 0 auto;
}

.login-card h2 {
  margin-top: 0;
}

.card-help {
  color: var(--text-muted);
  font-size: 0.9rem;
  margin-top: 0.25rem;
}

.login-form {
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.input-group {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  font-size: 0.92rem;
}

.input-group span {
  color: var(--text-muted);
}

.input-group input {
  padding: 0.6rem 0.8rem;
  border-radius: 0.65rem;
  border: 1px solid rgba(148, 163, 184, 0.6);
  background-color: rgba(15, 23, 42, 0.9);
  color: var(--text-main);
  outline: none;
  font-size: 0.95rem;
  transition: border-color 0.15s ease, box-shadow 0.15s ease, background-color 0.15s ease;
}

.input-group input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.5);
  background-color: rgba(15, 23, 42, 1);
}

.primary-btn {
  margin-top: 0.5rem;
  padding: 0.7rem 1rem;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  background: linear-gradient(135deg, #16a34a, #22c55e);
  color: #f9fafb;
  font-weight: 600;
  letter-spacing: 0.02em;
  box-shadow: 0 12px 30px rgba(16, 185, 129, 0.45);
  transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
}

.primary-btn:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: 0 16px 40px rgba(16, 185, 129, 0.55);
  filter: brightness(1.03);
}

.primary-btn:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: 0 10px 25px rgba(16, 185, 129, 0.4);
}

.primary-btn:disabled {
  opacity: 0.7;
  cursor: default;
}

.error-banner {
  margin-top: 0.5rem;
  padding: 0.6rem 0.8rem;
  border-radius: 0.6rem;
  background: rgba(248, 113, 113, 0.08);
  border: 1px solid rgba(248, 113, 113, 0.6);
  color: #fecaca;
  font-size: 0.88rem;
}

.results-card {
  width: 100%;
}

.results-header {
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
  margin-bottom: 1rem;
}

.results-header h2 {
  margin: 0;
}

.results-header p {
  margin: 0;
  color: var(--text-muted);
  font-size: 0.9rem;
}

.altgen-status {
  margin-top: 0.2rem;
  color: var(--text-muted);
  font-size: 0.86rem;
}

.badge {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.18rem 0.55rem;
  border-radius: 999px;
  font-size: 0.75rem;
  font-weight: 500;
}

.badge-on {
  background: rgba(34, 197, 94, 0.1);
  border: 1px solid rgba(34, 197, 94, 0.6);
  color: #bbf7d0;
}

.badge-off {
  background: rgba(148, 163, 184, 0.1);
  border: 1px solid rgba(148, 163, 184, 0.6);
  color: #e5e7eb;
}

.apply-controls {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 0.9rem;
}

.apply-hint {
  font-size: 0.82rem;
  color: var(--text-muted);
}

.apply-banner {
  margin-bottom: 0.9rem;
  padding: 0.6rem 0.8rem;
  border-radius: 0.6rem;
  background: rgba(34, 197, 94, 0.08);
  border: 1px solid rgba(34, 197, 94, 0.6);
  color: #bbf7d0;
  font-size: 0.86rem;
}

.top-controls {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-bottom: 0.9rem;
}

.filter-controls {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.84rem;
}

.filter-label {
  color: var(--text-muted);
  margin-right: 0.25rem;
}

.filter-btn {
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.7);
  background: rgba(15, 23, 42, 0.95);
  color: var(--text-main);
  padding: 0.25rem 0.65rem;
  font-size: 0.8rem;
  cursor: pointer;
}

.filter-btn-active {
  border-color: var(--accent);
  background: rgba(34, 197, 94, 0.14);
}

.filter-divider {
  width: 1px;
  height: 1.3rem;
  background: rgba(148, 163, 184, 0.5);
  margin-inline: 0.4rem;
}

.images-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
  gap: 1.1rem;
  margin-top: 0.5rem;
}

.image-card {
  border-radius: 0.9rem;
  border: 1px solid rgba(148, 163, 184, 0.3);
  background:
    radial-gradient(circle at 0 0, rgba(148, 163, 184, 0.18) 0, transparent 60%),
    rgba(15, 23, 42, 0.95);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.image-wrapper {
  position: relative;
  padding: 0.6rem;
  background: radial-gradient(circle at 0 0, rgba(34, 197, 94, 0.16) 0, transparent 55%);
}

.image-thumb {
  width: 100%;
  border-radius: 0.75rem;
  display: block;
  object-fit: cover;
}

.image-meta {
  padding: 0.7rem 0.75rem 0.8rem;
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}

.meta-row {
  display: flex;
  flex-direction: column;
  gap: 0.1rem;
  font-size: 0.85rem;
}

.meta-label {
  font-size: 0.78rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
}

.meta-value {
  color: #e5e7eb;
}

.meta-text {
  max-height: 3.4em;
  overflow: hidden;
  text-overflow: ellipsis;
}

.meta-alt {
  padding: 0.3rem 0.45rem;
  border-radius: 0.5rem;
  background: var(--accent-soft);
  border: 1px dashed rgba(34, 197, 94, 0.4);
}

.meta-alt.suggested-alt {
  background: rgba(56, 189, 248, 0.12);
  border-color: rgba(56, 189, 248, 0.5);
}

.alt-textarea {
  width: 100%;
  resize: vertical;
  min-height: 3.2rem;
  max-height: 8rem;
  border-radius: 0.6rem;
  border: 1px solid rgba(148, 163, 184, 0.7);
  background-color: rgba(15, 23, 42, 0.95);
  color: var(--text-main);
  padding: 0.45rem 0.6rem;
  font-size: 0.85rem;
  box-sizing: border-box;
}

.alt-textarea:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.5);
}

.apply-row {
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
}

.apply-checkbox {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.85rem;
  color: var(--text-main);
}

.apply-checkbox input {
  width: 1rem;
  height: 1rem;
}

.link-row {
  margin-top: 0.3rem;
  flex-direction: row;
  justify-content: space-between;
  gap: 0.4rem;
}

.post-link {
  font-size: 0.8rem;
  color: #38bdf8;
  text-decoration: none;
  border-bottom: 1px dashed rgba(56, 189, 248, 0.6);
}

.post-link:hover {
  color: #e0f2fe;
  border-bottom-style: solid;
}

.app-footer {
  position: relative;
  z-index: 1;
  padding: 0.75rem 1.5rem 1.2rem;
  text-align: center;
  color: var(--text-muted);
  font-size: 0.8rem;
}

@media (max-width: 640px) {
  .card {
    padding: 1.25rem 1.1rem;
  }

  .app-header {
    padding-inline: 1rem;
  }

  .app-main {
    padding-inline: 1rem;
  }

  .top-controls {
    align-items: flex-start;
  }

  .apply-controls {
    flex-direction: column;
    align-items: flex-start;
  }
}


⸻
